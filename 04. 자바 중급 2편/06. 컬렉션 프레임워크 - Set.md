# 06. 컬렉션 프레임워크 - Set

### 🔷 **Set**
>ㅤ✅ **`Set`은 중복을 허용하지 않고, 순서를 보장하지 않는 자료 구조이다.** <br>

<br>

<div align="center">
  <img width="40%" src="https://github.com/user-attachments/assets/9a6e1150-a2da-44eb-84ba-af7d0102c7d9">
</div> <br>

ㅤㅤ✔ `Set` 인터페이스는 `HashSet`, `LinkedHashSet`, `TreeSet` 등의 여러 구현 클래스를 가지고 있다. <br>
ㅤㅤ✔ `Set`은 **수학적 집합 개념을 구현**한 것. **순서를 보장하지 않고, 특정 요소가 집합에 있는지 여부를 확인**것에 최적화 <br>
ㅤㅤ✔ **`Set` 인터페이스의 주요 메서드** <br>

<div align="center">
  
|**메서드**|**설명**|
|:--:|:--:|
|`add(E e)`|**지정된 요소를 세트에 추가 (중복 x)**|
|addAll(Collection<? extends E> c)|지정된 컬렉션의 모든 요소를 세트에 추가|
|`contains(Object o)`|**세트가 지정된 요소를 포함하고 있는지 여부를 반환**|
|containsAll(Collection<?> c)|세트가 지정된 컬렉션의 모든 요소를 포함하고 있는지 여부를 반환|
|`remove(Object o)`|**지정된 요소를 세트에서 제거**|
|removeAll(Collection<?> c)|지정된 컬렉션에 포함된 요소를 세트에서 모두 제거|
|`retainAll(Collection<?> c)`|**지정된 컬렉션에 포함된 요소만을 유지**하고 나머지 요소는 세트에서 제거|
|clear()|세트에서 모든 요소를 제거|
|size()|세트에 있는 요소의 수를 반환|
|isEmpty()|세트가 비어 있는지 여부를 반환|
|iterator()|세트의 요소에 대한 반복자를 반환|
|toArray()|세트의 모든 요소를 배열로 반환|
|toArray(T[] a)|세트의 모든 요소를 지정된 배열로 반환|

</div> <br><br><br>

### 🔷 **HashSet**
ㅤㅤ✔ **구현**: **해시 자료 구조**를 사용해서 요소를 저장 <br>
ㅤㅤ✔ **순서**: 요소들은 **특정한 순서 없이** 저장 <br>
ㅤㅤ✔ **시간 복잡도**: `HashSet`의 주요 연산(추가, 삭제, 검색)은 평균적으로 **O(1)** 시간 복잡도를 갖음<br>
ㅤㅤ✔ **용도: 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합.** (`Set`이 필요한 경우 `HashSet`을가장 많이 사용) <br>
ㅤㅤ✔ **최적화**: 자바 `HashSet`의 기본 크기는 `16`. 배열 크기의 `75%`를 넘어가면 성능 떨어지기 시작 <br>
ㅤㅤㅤ🔹 **재해싱(rehashing)**: 75% 이상이 되면 배열의 크기를 2배로 증가하고 **모든 데이터의 해시 인덱스를 다시 계산**하는 것 <br><br><br>

### 🔷 **LinkedHashSet**
>ㅤ✅ **`LinkedHashSet`은 `HashSet`에 연결 링크만 추가한 것 (= `HashSet`에 `LinkedList`를 합친 것)** <br>

ㅤㅤ✔ **구현**: `HashSet`에 연결 리스트를 추가해서 요소들의 순서를 유지 (**양방향 연결**)<br>
ㅤㅤ✔ **순서**: 요소들은 **추가된 순서대로** 저장 <br>
ㅤㅤ✔ **시간 복잡도**: 주요 연산에 대해 평균적으로 **O(1)** 시간 복잡도를 갖음<br>
ㅤㅤ✔ **용도: 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합** <br><br>
ㅤㅤ✔ **참고**: 연결 링크를 유지해야 하기 때문에 `HashSet` 보다는 조금 더 무겁다. <br><br><br>

### 🔷 **TreeSet**
ㅤㅤ✔ **구현**: **이진 탐색 트리**를 개선한 **레드-블랙 트리**를 내부에서 사용 <br>
ㅤㅤ✔ **순서**: 요소들은 **정렬된 순서로 저장**.  순서의 기준은 **비교자(Comparator)**로 변경할 수 있다 <br>
ㅤㅤ✔ **시간 복잡도**: 주요 연산에 대해 평균적으로 **O(log n)** 시간 복잡도를 갖음<br>
ㅤㅤ✔ **용도: 데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용** <br>
ㅤㅤㅤㅤex) 범위 검색, 정렬된 데이터가 필요한 경우 <br><br>


ㅤㅤ❓ **이진 탐색 트리** <br><br>

<div align="center">
  <img width="60%" src="https://github.com/user-attachments/assets/962ea9d3-ad2f-4283-bb08-273efc2afa54">
</div> <br>

ㅤㅤㅤ🔹 트리는 부모 노드와 자식 노드로 구성됨 (최상위 노드를 루트(root)라고 함) <br>
ㅤㅤㅤ🔹 자식이 2개까지 올 수 있는 트리를 **이진 트리**라고 함 <br>
ㅤㅤㅤ🔹 **이진 탐색 트리: 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손은 더 큰 값을 가지는 것** <br>
ㅤㅤㅤ🔹 **이진 탐색 트리 계산의 핵심은 한번에 절반을 날린다는 점 (O(n)과 비교해서 데이터의 크기가 클 수록 효과적)** <br>

<!--
공백문자: "ㅤ" or &nbsp;
### 🔷 ****
>ㅤ✅ **** <br>
ㅤㅤ:  <br>
ㅤㅤㅤex) <br>
ㅤㅤ✔ **** <br>
ㅤㅤㅤ🔹 **** <br>
ㅤㅤㅤㅤㅤ- **** <br>
➡️
ㅤㅤㅤㅤㅤex) <br>
ㅤㅤ❗ <br>
ㅤㅤ❓ <br>
ㅤㅤ✅ <br>
ㅤㅤㅤㅤ**▪️** <br>
ㅤㅤㅤㅤ**▫️** <br>
ㅤㅤ**1️⃣** <br>
ㅤㅤ**2️⃣** <br>
ㅤㅤ**3️⃣** <br>
ㅤㅤ**4️⃣** <br>
ㅤㅤ**5️⃣** <br>
ㅤㅤ**🤔** <br>
> [!NOTE]  
> [!TIP]
> [!IMPORTANT]  
> [!WARNING]  
> [!CAUTION]


**💡 예시**
```JAVA

```


<details><summary>💡예시 코드</summary>

```JAVA

```
</details>

<br>

<div align="center">
  <img width="70%" src="">
</div> <br><br>


<div align="center">
|****|****|****|
|:--:|:--:|:--:|
||||
</div> 
-->

# 06. 스코프, 형변환

### 🔹 **지역변수 (Local Variable)**
ㅤㅤ: 자신이 선언된 코드블록 안에서만 접근(사용)가능한 변수 <br><br>

### 🔹 **스코프**
ㅤㅤ: 변수의 접근 가능한 **범위** <br>

ㅤ❗ **스코프 존재 이유** <br>

ㅤㅤ1️⃣ **비효율적인 메모리 사용 방지**<br>
ㅤㅤㅤㅤ: 잠깐 사용될 변수는 특정 코드블록 내에서만 생존할 수 있게 하여 메모리 절약<br>
ㅤㅤ2️⃣ **코드 복잡성 증가 방지**<br>
ㅤㅤㅤㅤ: 개발 & 유지보수 중 신경써야할 변수가 감소하여 휴먼 에러를 줄일 수 있다. <br>

ㅤㅤ✔ 변수는 꼭 필요한 범위로 한정하여 사용하는 것이 좋다.<br>
ㅤㅤ✔ 좋은 프로그램은 무한한 자유가 있는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.<br><br>

### 🔹 **자동 형변환**
ㅤㅤ: 작은 범위에서 큰 범위로 값을 넣었을 때 **자동적으로 타입이 변환**되는 Java의 기능 <br>
ㅤㅤㅤex) `int` **→** `long` **→** `double`<br>

### 🔹 **명시적 형변환**
ㅤㅤ: 큰 범위에서 작은 범위로 값을 넣을 때는 `소수점 버림`과 `오버플로우`가 발생할 수 있다.<br>
ㅤㅤㅤ이러한 위험을 방지하기위해 **개발자가 직접 타입을 변환**하는 방식을 `명시적 형변환`이라 한다.<br>

```Java
    # 명시적 형변환 예시
      intValue = (int) doubleValue;
```

ㅤㅤ❓ **오버플로우**(Overflow) <br>
ㅤㅤㅤㅤ: `int`의 표현 범위는 -2147483648 ~ 2147483647이다. 만약 2147483647보다 1 큰 수를 int형으로 형변환하려 한다면,<br>
ㅤㅤㅤㅤㅤ표현 가능한 최대값인 2147483647까지 표현되고 남은 하나만큼 다시 처음 값인 -2147483648부터 표현된다. <br>
ㅤㅤㅤㅤㅤ이런 오류를 오버플로우라고 한다.<br><br>

### 🔹 **계산과 형변환**

```Java
package casting;

public class CastingEx {
    public static void main(String[] args) {
        int div1 = 3 / 2;
        System.out.println("div1 = " + div1);

        double div2 = 3 / 2;
        System.out.println("div2 = " + div2);

        double div3 = 3.0 / 2;
        System.out.println("div3 = " + div3);

        double div4 = (double) 3 / 2;
        System.out.println("div4 = " + div4);

        int a = 3;
        int b = 2;
        double result = (double) a / b;
        System.out.println("result = " + result);
    }
}

>>
div1 = 1
div2 = 1.0
div3 = 1.5
div4 = 1.5
result = 1.5
```
<br>

ㅤㅤ✔ **같은 타입끼리의 계산은 같은 타입의 결과를 낸다.** <br>
ㅤㅤ✔ **서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어난다.** <br>
ㅤㅤ✔ **형변환은 읽기 단계에서 일어나기에 기존 변수의 자료형은 타입 변환이 없다.** <br>

<!--
공백문자: "ㅤ" or &nbsp;
### 🔹 ** **
ㅤㅤ:  <br>
ㅤㅤㅤex) <br>
ㅤㅤ✔ <br>
ㅤㅤㅤㅤㅤex) <br>
ㅤㅤ❓ <br>
ㅤㅤㅤㅤㅤex) <br>
ㅤㅤ❗ <br>
ㅤㅤㅤㅤㅤex) <br>

1️⃣ <br>
2️⃣ <br>
3️⃣ <br>
4️⃣ <br>
5️⃣ <br>
6️⃣ <br>
ㅤㅤㅤ:<br>
-->
